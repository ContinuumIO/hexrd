# ============================================================
# Copyright (c) 2012, Lawrence Livermore National Security, LLC. 
# Produced at the Lawrence Livermore National Laboratory. 
# Written by Joel Bernier <bernier2@llnl.gov> and others. 
# LLNL-CODE-529294. 
# All rights reserved.
# 
# This file is part of HEXRD. For details, see https://github.com/joelvbernier/hexrd.
# 
# Please also see the file LICENSE.
# 
# This program is free software; you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License (as published by the Free Software
# Foundation) version 2.1 dated February 1999.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the IMPLIED WARRANTY OF MERCHANTABILITY 
# or FITNESS FOR A PARTICULAR PURPOSE. See the terms and conditions of the 
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this program (see file LICENSE); if not, write to
# the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
# Boston, MA 02111-1307 USA or visit <http://www.gnu.org/licenses/>.
# ============================================================
import copy
from math import sqrt

import numpy as num
from numpy import dot,sqrt
from scipy.linalg import eig

import hexrd.Vector_funcs as vf
import hexrd.Diffraction_Analysis_10 as da
from hexrd.Vector_funcs import Rodrigues3,e1func,e2func,e3func,Unit,Mag
import hexrd.orientations as ors
from hexrd.XRD.Rotations import rotMatOfQuat
import hexrd.arrayUtil
from hexrd import plotWrap

debug = True

######################################################################

'''
... things to think about:
(*) from images, get what? -- reciprocal vectors? lattice vectors?
(*) makeSpots should be makeRecipVecs? rotation matrices work on reciprocal vectors? or on direct lattice vectors?
(*) most of things here that are called latVec* are actually plane normals, and really need something else
(*) need to check formulat for calculating reciprocal vectors for Friedel pairs
(*) MakeFiber and the like probably need plane normals, not reciprocal vectors




*** latVec -> latPlnNrml

spotData...***
	scattering vector components
	2-theta, eta, omega
        friedel pair identification
makeSpots should spit out a spotData instance?

...*** for GrainIndexerFS, what information should findAllSpots use?

'''
def makeSpots(quats, latVecs, scramble=False):
    Rs   = rotMatOfQuat(quats)
    temp = num.dot(Rs,latVecs)
    nRs = Rs.shape[0]
    nVs = latVecs.shape[1]
    spots = temp.swapaxes(1,2).reshape(nRs*nVs,3)
    if scramble:
        ns = nRs * nVs
        order = num.random.random(len(spots))
        spots = arrayUtil.structuredSort(order, spots)
        # dtype = [('rand', float), ('v0', float), ('v1', float), ('v2', float)]
        # a = num.array([tuple(num.hstack((num.random.random(), spots[i,:])).tolist()) for i in range(ns)], dtype=dtype)
        # aSorted = num.sort(a, order='rand')
        # #aSorted = num.sort(a, axis='rand')?
        # spots = num.vstack((aSorted['v0'], aSorted['v1'], aSorted['v2'])).T
    return spots
def findAllSpots(quat, gIs, rIs, search_radius = 'default'):
    """gIs,rIs -> VectorDataStructure
    returns: an inv_dict with hkl keys, and a list of rI point id's for each hkl slot"""
    return Query_Orientation(gIs,rIs,quaternion_map(quat),search_radius)

def findAllSpots(quat, spotRecip, latVecs, distanceToler):
    '''
    looks something link forward diffraction simulator?
    make sure gets both omega solutions;
    put spots into bins for faster testing of alignment? (like binnedBox in map.py?)
    
    return indices into spotRecip for spots that align with those 
    generated by lattice vectors latVecs for a grain at orientation quat
    '''
    spotsFound = []
    
    raise RuntimeError, 'need implementation'
    
    spotsFound = num.array(spotsFound)
    return spotsFound

def calcTwoTheta(recipVec,wavelength,tol=10**-4):
    """use 2dsin(theta) = wavelength, and d = 1/|g^i|, where g^i is the reciprocal vector, |.| is regular vector magnitude (2 norm)"""
    magnitude = Mag(recipVec)
    d = magnitude**-1
    sintheta = wavelength/(2*d)
    #reject sintheta > 1.0001 (arbitrary cutoff)
    if(sintheta>1):
        if abs(sintheta-1)>tol:
            raise RuntimeError, 'no diffraction for this vector at this wavelength'
        else:
            sintheta = 1    
    theta = asin(sintheta)
    twotheta = 2*theta
    #raise RuntimeError, 'need implementation' # ...
    return twotheta

def findClumpInPlane(angles):
    if debug:
        pw = plotWrap.PlotWrap()
        pw(num.cos(angles), num.sin(angles), style='bo')
        #import pylab as p
        #p.ion()
        #p.show()
        pw.destroy()
    raise RuntimeError, 'need implementation' # ...
    return inClump, inPlaneAngle

class MakeFiber:
    """make fiber from two rotation related vectors including fancy basis stuff
    input: vector1, vector2
    attributes: .e1,.e2, the basis vectors in R4 which span the plane containing the fiber traversal geodesic on S3
    
example usage:
from hexrd.grainIndex import MakeFiber
import numpy
from numpy import dot
a1 = numpy.array([4,5,3])

from hexrd.Vector_funcs import *
R = Rodrigues3(e3func(),.3) #angle axis

a2 = dot(R,a1)
f1 = MakeFiber(a1,a2)
b1 = numpy.array([-6,4,5])
b2 = dot(R,b1)
f2 = MakeFiber(b1,b2)
dist_,Closest_Rotation = f1.distBetweenFibers(f2)
#or, equivalently
dist_,Closest_Rotation = f1-f2 #== f2-f1
#dist_ ~= 1 
#Closest_Rotation ~= R

    """
    def __init__(self, latVec, recipVec):

        '''
        this ors stuff in here because it gets used in constructOrientation,
        but ultimately it will probably go away
        '''
        self.latVec   = latVec
        self.recipVec = recipVec
        self.qBase  = q1  = ors.Quat(ors.RotInv('align', Unit(latVec), Unit(recipVec)))
        e1 = q1.q
        Rfiber = Rodrigues3(Unit(recipVec),.5) #.5 is a very arbitary distance along the fiber
        q2 = ors.Quat(Rfiber)
        q12 = (q2*q1).q
        e2 = Unit(q12 - dot(q12,e1)*e1)
        self.e1 = e1
        self.e2 = e2

    def __sub__(self,other):
        return self.distBetweenFibers(other)        
    def distBetweenFibers(self,other):
        """
Compute the distance between two fibers using the polar decomposition of the projection operator taking one geodesic plane to the other. 
input: instance of MakeFiber class
output: (max_eigenvalue, Rotation at max_eigenvalue), intersecting fibers would have max_eigenvalue ~ 1. Rotation at max_eigenvalue would be the 'closest' Rotation which would relate the two fibers.
        """
        e1,e2 = self.e1,self.e2
        e1_,e2_ = other.e1,other.e2
        F11 = dot(e1,e1_);F12 = dot(e1,e2_);
        F21 = dot(e2,e1_);F22 = dot(e2,e2_);
        #not guaranteed to be non singular... most of the time seems to work though
        F = num.array([[F11,F12],[F21,F22]])
        #want to use F = R.U for F non singular
        #eigenvalues of U give measure of fiber distance
        #R*eigenvector(U) gives quaternion at min/max fiber distance on e1,e2 (self's) basis
        C = dot(F.T,F)
        eval,evec = eig(C)
        l1,l2 = map(float,eval);
        u1,u2 = evec[:,0],evec[:,1]        
        if(l1>l2):
            max_eval = l1
            max_evec = u1
        else:
            max_eval = l2
            max_evec = u2
        #had non orthogonal u1,u2 once with C++ implementation using lapack::geev which is probably what scipy uses, so keep this "if ..." safeguard unless there is a better safeguard against finding non orthogonal eigenvectors
        if dot(u1,u2)>10**-4:
            tmp = num.zeros(3)
            tmp[0] = u1[0]
            tmp[1] = u1[1]
            tmp[2] = 0.
            tmp2 = num.cross(e3func(),tmp)
            u2[0] = tmp2[0]
            u2[1] = tmp2[1]
        #polar composition F = R.U, F^TF = U^2 = C, R = F.U^-1
        #U = sqrt(abs(l1))*num.outer(u1,u1)+sqrt(abs(l2))*num.outer(u2,u2)
        U_inv = (1./sqrt(abs(l1)))*num.outer(u1,u1) + (1./sqrt(abs(l2)))*num.outer(u2,u2)
        R = dot(F,U_inv)
        Ru1 = dot(R,max_evec)
        q_min_dist = Ru1[0]*e1 + Ru1[1]*e2
        #check for consistency
        q1_ = dot(q_min_dist,e1_)
        q2_ = dot(q_min_dist,e2_)
        #max_eval = max(l1,l2)
        #just for initial testing of the fiber method, trying to understand the properties
        if(abs(sqrt(q1_**2+q2_**2)-Mag(q_min_dist))>10**-3 and max_eval>=.9999):
            raise Exception, 'min dist quaternion is not in both planes'
           
        R_min_dist = da.quaternion_map(q_min_dist)
        return max_eval,R_min_dist

    def constructOrientation(self, angle):
        qAxis = ors.Quat(ors.RotInv(angle, self.latVec))
        qCur  = self.qBase * qAxis
        return qCur.q

######################################################################

class GrainIndexer:
    '''template;
    classes inheriting from this one are expected to implement their own call method'''
    def __init__(self,
                 planeData,
                 friedelToler = 0.01
                 ):
        '''
        planeData : instance of lparm.PlaneData
        friedelToler : tolerance for identifying Friedel pairs
        '''
        self.planeData  = planeData

        self.friedelToler = friedelToler

        self.symmGroup    = self.planeData.getSymmGroup()
        self.qsym         = self.planeData.getSQym()
        
        return
    def __call__(self, 
                 spotRecip,
                 *args,
                 **keyArgs):
        raise RuntimeError, 'need implementation'
        return
    @staticmethod
    def doFriedelAssoc(spotRecip, toler):
        '''Friedel pair associations;
        non-zero is index of Friedel pair; 
        eg : friedelPair[2] = 4; friedelPair[4] = 2
        '''
        nSpots = len(spotRecip)
        friedelPair = num.zeros([nSpots],dtype=int)
        friedelPair[:] = -1
        for iSpot in range(nSpots-1):
            if friedelPair[iSpot] >= 0: continue # already associated
            thisSpot = spotRecip[iSpot,:]
            diffs  = num.tile(thisSpot,(nSpots-iSpot-1,1)) + spotRecip[iSpot+1:,:]
            mags   = num.apply_along_axis(num.linalg.norm, 1, diffs)
            minloc = num.argmin(mags)
            jSpot = minloc+iSpot+1
            if minloc >= nSpots:
                raise RuntimeError, 'what gives?'
            if mags[minloc] <= toler and friedelPair[jSpot] < 0:
                friedelPair[iSpot] = jSpot
                friedelPair[jSpot] = iSpot
        return friedelPair
    @staticmethod
    def Find_Friedel_Pairs(rIs,search_radius = 'default'):
        """rIs is a Vector_Data_Structure object"""
        friedel_pairs = inv_dict()
        for rI_index in rIs.raw_data.keys():
            rI = rIs.raw_data[rI_index]
            friedel_pair = -rI
            pairs_found = rIs.Query_Point(friedel_pair,search_radius)
            for pair_found in pairs_found:
                friedel_pairs.Add(rI_index,pair_found)
        #friedel_pairs:{dataid1 : fridelpair_of_dataid1}
        #friedel_pairs:{dataid2 : (fridelpair1_of_dataid2, friedelpair2_of_dataid2,...)
        
        return fridel_pairs

            
    @staticmethod
    def findClosest(distances, distanceToler, nFibersMax=None):
        '''
        something like a truncated bubble sort might work, though there may be more efficient ways
        '''
        
        # 'direct use of num argsort:'
        # argSort = num.argsort(distances)
        
        'first cull ones which are too far, keeping indices attached, then sort'
        closeEnough = num.array(distances) < distanceToler
        dtype = [('index', int), ('dist', float)]
        a = num.array([(i,distances[i]) for i in range(len(distances))], dtype=dtype)
        a = a[closeEnough]
        aSorted = num.sort(a, order='dist')
        indices = aSorted['index']
        
        if nFibersMax is not None:
            'return at most nFibersMax'
            indices = indices[0:min(len(indices), nFibersMax)]
        
        return indices

class GrainIndexerDTO(GrainIndexer):
    '''brute force approach:
    compute distances from fibers to a host of trial orientations'''
    def __init__(self, *args, **keyArgs):
        return
    def __call__(self):
        return

class GrainIndexerFS(GrainIndexer):
    '''grain indexer which steps along fibers to look for matches with spots
    ... model after FindMesauredQ.m?
    '''
    def __init__(self, *args, **keyArgs):
        '''
        See __init__ method for GrainIndexer class
        
        additional keyword arguments:

          stepSize : step size along fibers in radians
          
          hklsAll : hkls to use for find spots once a grain is nominally indexed
                    defaults to None, in which case self.hkls
                    (set in GrainIndexer.__init__()) are used instead
        '''
        
        # defaults
        self.hklsAll=None
        self.grainList = []
        self.nFibersMinToLookDflt = 3
        self.stepSize = 0.02
        #
        # parse subset of keyArgs
        if keyArgs.has_key('hklsAll'):
            self.hklsAll = keyArgs.pop('hklsAll')
        if keyArgs.has_key('stepSize'):
            self.stepSize = keyArgs.pop('stepSize')

        GrainIndexer.__init__(self, *args, **keyArgs)

        if self.hklsAll is not None:
            self.latVecsAll = lparm.PlaneData(self.hklsAll, self.planeData).getPlaneNormals()
        else:
            self.latVecsAll = self.planeData.getPlaneNormals()
        
        return
    def __call__(self, 
                 spotRecip,
                 nFibersMin,
                 nFibersMax,
                 distToler=None
                 ):
        
        nSpots = len(spotRecip)
        assert spotRecip.shape[1] == 3, 'spotRecip shape'

        distanceToler = self.stepSize*0.9
        if distToler is not None:
            distanceToler = distToler
        
        nFibersMinToLook = min(nFibersMin, self.nFibersMinToLookDflt)
        
        ' whether spot has been claimed in indexing so far'
        spotClaimed = num.array([False for iSpot in range(nSpots)])

        ' first deal with grainList -- grains found from some previous indexing '
        if len(self.grainList) > 0:
            foundGrain = num.array([False for iGrain in len(self.grainList)])
            for iGrain in len(self.grainList):
                quat = grainList[iGrain][0]
                spotsThis = findAllSpots(quat, spotRecip, self.latVecsAll, distanceToler)
                if len(spotsThis) < nFibersMin:
                    foundGrain[iGrain] = False
                    print 'Warning: lost grain at quat : '+str(quat)
                else:
                    foundGrain[iGrain] = True
                    if num.any(spotClaimed[spotsThis]):
                        print 'Warning: spot(s) already claimed'
                    spotClaimed[spotsThis] = True
        
        friedelPair = self.doFriedelAssoc(spotRecip, self.friedelToler)
        friedelMasterB = friedelPair[:] > num.arange(nSpots,dtype=int)
        friedelMasterI = num.where(friedelMasterB)[0]
        nFriedel = num.sum(friedelMasterB)
        
        ' get reciprocal vectors or whatever for Friedel pairs '
        #friedelRecip = num.zeros([nFriedel,3])
        # ... something like:?
        # ...*** # is the following correct? put in higher level data structure?
        friedelRecip = spotRecip[friedelMasterI,:] - \
            0.5 * (spotRecip[friedelMasterI,:] + spotRecip[friedelPair[friedelMasterI],:])
        
        #...*** # what should be doing here?
        twoTheta = calcTwoTheta(friedelRecip) # ... need self.wavelength, see lparm.latticePlanes
        
        hklDataList = copy.deepcopy(self.hklDataList)
        for hklData in hklDataList:
            ' determine boolean for whether spot might be in 2-theta range to be considered '
            hklData['isCandidateB'] = twoTheta > hklData['2thetaLo'] and twoTheta < hklData['2thetaHi']

        for hklData in hklDataList:
            isCandidateB = hklData['isCandidateB']
            #isCandidateI = num.where(isCandidateB)[0]
            latPlnNrmlList      = hklData['latPlnNrmlList']
            
            for iFriedel in range(nFriedel):
                if spotClaimed[friedelMasterI[iFriedel]]: continue
                if not isCandidateB[iFriedel]: continue
                
                currentFiber = MakeFiber(latPlnNrmlList[0], friedelRecip[iFriedel,:])
                
                # ... for fibers aligned with symmetry operators, do not
                # have to do full 2*pi as just end up repeating; so could
                # specialize to give up sooner for those fibers
                for inPlaneAngle in num.arange(0., 2*num.pi, self.stepSize):
                    quat = currentFiber.constructOrientation(inPlaneAngle)
                    spotsThis = findAllSpots(quat, spotRecip, self.latVecsAll, distanceToler)
                    if len(spotsThis) >= nFibersMin:
                        foundGrain[iGrain] = True
                        if num.any(spotClaimed[spotsThis]):
                            print 'Warning: spot(s) already claimed'
                        spotClaimed[spotsThis] = True
                        continue
        
        return

class GrainIndexerDBF(GrainIndexer):
    'grain indexer which uses distance-between-fibers based method'
    def __init__(self, *args, **keyArgs):
        '''
        See __init__ method for GrainIndexer class
        
        additional keyword arguments:
          
          hklsAll : hkls to use for find spots once a grain is nominally indexed
                    defaults to None, in which case self.hkls
                    (set in GrainIndexer.__init__()) are used instead
        '''
        
        # defaults
        self.hklsAll=None
        self.grainList = []
        self.nFibersMinToLookDflt = 3
        #
        # parse subset of keyArgs
        if keyArgs.has_key('hklsAll'):
            self.hklsAll = keyArgs.pop('hklsAll')

        GrainIndexer.__init__(self, *args, **keyArgs)

        if self.hklsAll is not None:
            self.latVecsAll = lparm.PlaneData(self.hklsAll, self.planeData).getPlaneNormals()
        else:
            self.latVecsAll = self.planeData.getPlaneNormals()
        
        return
    def __call__(self, 
                 spotRecip,
                 nFibersMin,
                 nFibersMax,
                 distanceToler
                 ):
        
        nSpots = len(spotRecip)
        assert spotRecip.shape[1] == 3, 'spotRecip shape'

        nFibersMinToLook = min(nFibersMin, self.nFibersMinToLookDflt)
        
        ' whether spot has been claimed in indexing so far'
        spotClaimed = num.array([False for iSpot in range(nSpots)])

        ' first deal with grainList -- grains found from some previous indexing '
        if len(self.grainList) > 0:
            foundGrain = num.array([False for iGrain in len(self.grainList)])
            for iGrain in len(self.grainList):
                quat = grainList[iGrain][0]
                spotsThis = findAllSpots(quat, spotRecip, self.latVecsAll, distanceToler)
                if len(spotsThis) < nFibersMin:
                    foundGrain[iGrain] = False
                    print 'Warning: lost grain at quat : '+str(quat)
                else:
                    foundGrain[iGrain] = True
                    if num.any(spotClaimed[spotsThis]):
                        print 'Warning: spot(s) already claimed'
                    spotClaimed[spotsThis] = True
        
        friedelPair = self.doFriedelAssoc(spotRecip, self.friedelToler)
        friedelMasterB = friedelPair[:] > num.arange(nSpots,dtype=int)
        friedelMasterI = num.where(friedelMasterB)[0]
        nFriedel = num.sum(friedelMasterB)
        
        ' get reciprocal vectors or whatever for Friedel pairs '
        #friedelRecip = num.zeros([nFriedel,3])
        # ... something like:?
        friedelRecip = spotRecip[friedelMasterI,:] - \
            0.5 * (spotRecip[friedelMasterI,:] + spotRecip[friedelPair[friedelMasterI],:])
        
        twoTheta = calcTwoTheta(friedelRecip) # ... need self.wavelength, see lparm.latticePlanes
        
        hklDataList = copy.deepcopy(self.hklDataList)
        for hklData in hklDataList:
            ' determine boolean for whether spot might be in 2-theta range to be considered '
            hklData['isCandidateB'] = twoTheta > hklData['2thetaLo'] and twoTheta < hklData['2thetaHi']

        for hklData in hklDataList:
            isCandidateB = hklData['isCandidateB']
            #isCandidateI = num.where(isCandidateB)[0]
            latPlnNrmlList      = hklData['latPlnNrmlList']
            
            for iFriedel in range(nFriedel):
                if spotClaimed[friedelMasterI[iFriedel]]: continue
                if not isCandidateB[iFriedel]: continue
                
                currentFiber = MakeFiber(latPlnNrmlList[0], friedelRecip[iFriedel,:])
                
                if nFibersMin == 2:
                    'different stuff where look for grain as soon as 2 fibers are close enough'
                    raise RuntimeError, 'may want to code special case for nFibersMin = 2'
                    # inPlaneAngle = ...
                    # indices = ...
                else:
                    distances = []
                    angles = []
                    for hklDataInner in hklDataList:
                        for latVecInner in hklDataInner['latPlnNrmlList']: # take care of symmetries (necessary?!)
                            toCompare = not spotClaimed[friedelMasterI[:]]
                            toCompare[0:iFriedel+1] = False
                            toCompare = toCompare and hklDataInner['isCandidateB']

                            for recipVec in friedelRecip[toCompare,:]:
                                distThis, angThis = currentFiber.distBetweenFibers(
                                    latVecInner, recipVec)
                                distances.append(distThis)
                                angles.append(angThis)
                    distances = num.array(distances)
                    angles    = num.array(angles)
                    
                    'find the closest fibers within a given distance tolerance'
                    indices = self.findClosest(distances, distanceToler, nFibersMax)
                    
                    'look at clustering and claim only those close to a single orientation'
                    inClump, inPlaneAngle = findClumpInPlane(angles[indices])
                    indices = indices[inClump]
                
                if len(indices)+1 < nFibrersMinToLook:
                    'not enough fibers to bother looking for a grain'
                    pass
                else:
                    'try to find grain orientation'
                    quat = currentFiber.constructOrientation(inPlaneAngle)
                    spotsThis = findAllSpots(quat, spotRecip, self.latVecsAll, distanceToler)
                    assert len(spotsThis) >= len(indices+1), \
                        'missing some?'
                    if len(spotsThis) >= nFibersMin:
                        if num.any(spotClaimed[spotsThis]):
                            print 'Warning: spot(s) already claimed'
                        spotClaimed[spotsThis] = True
                        self.grainList.append([quat, spotsThis])
            # end of iFriedel loop
        # end of hklData loop
        
        nClaimed = num.sum(spotClaimed)
        nGrains  = len(self.grainList)
        print 'found %d grains and claimed %d out of %d spots' % (nGrains, nClaimed, nSpots)
        
        return self.grainList # ... and whatever else

# ... tools for ploting frames, with spots identified

######################################################################

def main(argv=[]): 
    nGrains = 10
    
    indexerType = 'DBF'
    if len(argv) > 0:
        indexerType = argv[0]
    
    #hkls = num.array([[2.,-1.,0.]]).T # to use in indexing
    hkls = num.array([[2.,-1.,0.],[0.,0.,.1]]).T # to use in indexing
    lparms = 8.*num.array([1.0, 2.*sqrt(2./3.)]) # [a, c] # ... need real values
    wavelength = 1.54059292 # Angstrom # ... need real value
    laueGroup = 'D6h'
    strainMag = 0.02

    planeData = lparm.PlaneData(hkls, lparms, laueGroup, wavelength, strainMag)
    if indexerType == 'DBF':
        indexer = GrainIndexerDBF(planeData)
    elif indexerType == 'FS':
        indexer = GrainIndexerFS(planeData, stepSize=0.02)
    elif indexerType == 'DTO':
        raise NotImplementedError('in grainIndex')
        #indexer = GrainIndexerDTO(planeData)...
    else:
        raise RuntimeError, 'unknown indexerType : '+str(indexerType)
    print 'indexer will index using lattice vectors : \n'+str(indexer.getLatPlnNmrls())
    
    # make synthetic spots
    grainQuats = ors.Quat.getRandQuat(nGrains)
    hklsAll = num.array([[2.,-1.,0.],[0.,0.,1.],[1.,0.,1.]]).T
    latVecsAll = lparm.PlaneData(hklsAll, planeData)
    print 'will generate spots using lattice vectors : \n'+str(latVecsAll)
    #
    #...*** # need to do something that includes 2-theta information
    spotRecip = makeSpots(grainQuats.T, latVecsAll.T, scramble=True)
    
    grainList = indexer(spotRecip, 3, 200, 0.05)
    
    return grainQuats, spotRecip, indexer, grainList

# or to run under pdb:
# import pdb
# pdb.run('main()')
# b 50 # set breakpoint at line 50
######################################################################

if __name__ == '__main__':
    import sys
    grainQuats, spotRecip, indexer, grainList = main(sys.argv[1:])

